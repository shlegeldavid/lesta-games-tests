# Вопрос 1.
# Оригинальный алгоритм:

def isEven(value):
      return value % 2 == 0


#Аналогичный алгоритм:
#По умолчанию словарь (хэш-таблица), так как в ней поиск идет за O(1)
def memoizing_even(value, memory=dict()): #При инициализации функции передаем в нее число и "память".
    if value in memory: #Проверяем, есть ли значение в памяти.
        return True

    if value % 2 == 0:

        #Далее происходит проверка типа памяти, это добавлено, чтоб можно было выбирать между словарем и списком.
        if type(memory) is dict:
            memory[value] = True

        if type(memory) is list:
            memory.append(value)

        return True
    return False


#Плюсы первого алгоритма:
    #Он легкочитаемый и понятный
    #Расходует мало памяти 
    #Время выполнения O(1)
#Минусы:
    #Одинаковые значения все равно приходится пересчитывать


#Плюсы второго алгоритма:
    #Время выполнения также O(1)
    #Сохраняет уже отработанные данные в память, чтобы не тратить ресурсы на повторное вычисление
#Минусы:
    #При большом количестве операций расходует много памяти
